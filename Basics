Chapter 1 : Goals of OOPS

OOPS:
"Object technology is the combination of four core ideas: a structuring method, a
reliability discipline, an epistemological principle and a classification technique". 

                      OOPS
                       |
                       |
---Structure, reliability, epistemology and classification---

Page: 8

Structure:
  The structuring method applies to software decomposition and reuse.
                      Structure
                         |
                         |
            software decomposition and reuse

  Decomposition: Process of breaking down the something complex into simpler and manageable one. 
  Software decomposition : software decomposition is a process of beaking down the system into simpler and manageble modules or components,
                           simplifying the design, development, testing, and maintenance of the software system. 

Class covers here

Reliability :

  what is reliability? , reliability something we can trust , that it will do what is suppose to do, without unexpected failures.
  
  Reliability discipline : is a approach/ablity of software system do what is suppose to do , without unexpected failures.

contract covers here

Epistemological principle:

  Its a idea of describing an object by its external feature rather than internal working and implementation.
  
  This principle asks a question , how do we describe a classes ?
  
  In object technology object is descibed by its class , what we can do with it(features).
  
  Example: Sort() is a class , where sort object  describes that we can do sorting activity using this class , here the internal working and implementation is 
  not described rather its gives a general and external feature that this object do sorting.
  
  Abstraction , modularity , encapsulation cover these area.

Classification technique:

  Classification technique is process of organizing and categorizing the object in a hierarchies based on their characteristics and behaviors.
  This helps in managing and structuring complex system by grouping related objects together.

  InHeritance cover these area.

-------------------------------------------------------------------------------------------------


Software Quality:

 Engineering seeks quality,software engineering is the production of quality software.

  We all want our software systems to be fast, reliable, easy to use, readable, modular,
  structured and so on. But these adjectives describe two different sorts of qualities.

               Software Quality
                      |
                      |
        EXTERNAL AND INTERNAL FACTORS

  1.User want's software to be speed , ease of use. these are called EXTERNAL factors.
  2. Other quality's like readable, modular are INTERNAL FACTORS , these factors are cared for Software devlopers who are accessing the software code.
  
  In the End only External factor matters. only EXTERNAL factors are will used to scale a application from user end.
  
  But the key to achieving these external factors is in the internal ones

      EXTERNAL FACTORS
            |  
            |
Correctness,Robustness,Extendibility,Reusability,Compatibility,Efficiency,Portability,Ease of use,Functionality,Timeliness


Correctness: 
 Correctness is ability of software system that it should do perform its task. as per the system requirement.
Robustness:
 Robustness is a ability of software system that it should handle the unexpected/abnormal/out of scope situation.   
  an abnormal case is simply a case that is not covered by the specification or requirement.
Extendibility: 
  Extendibility is ease of adapting software system to the new change in requiremnt /specification.
  a software system should be designed with simple design and decentralised.
Reusability:
  Reusability is a ability of software components to reused in many other software appliaction.
Compatibility:
  Compatibility is ease of combining software elements with others.
Efficiency:
  Efficiency is a ability of a software system . which considers processing time and space occupied.
Portability:
 Portability is the ease of transferring software products to various hardware
 and software environments.
Ease of use:
  Ease of use is the ease with which people of various backgrounds and
 qualifications can learn to use software products and apply them to solve
 problems. It also covers the ease of installation, operation and monitoring. 
Functionality:
  Functionality is the extent of possibilities provided by a system.
Timeliness:
  Timeliness is the ability of a software system to be released when or before
  its users want it


Documentation:
• The need for external documentation, which enables users to understand the power
of a system and use it conveniently, is a consequence of the definition of ease of use. 
• The need for internal documentation, which enables software developers to
understand the structure and implementation of a system, is a consequence of the
extendibility requirement. 
• The need for module interface documentation, enabling software developers to
understand the functions provided by a module without having to understand its
implementation, is a consequence of the reusability requirement. It also follows from
extendibility, as module interface documentation makes it possible to determine
whether a certain change need affect a certain module.


Correctness and robustness -->reliability
Extendibility and reusability--> modularity

SOFTWARE MAINTENANCE
Maintenance is what happens after a software product has been delivered.
Discussions of software methodology tend to focus on the development phase; so do
introductory programming courses. But it is widely estimated that 70% of the cost of
software is devoted to maintenance.

Chapter 2 : Criteria of OOPS

->what makes a system object-oriented?
 
->criteria for assessing objectness

• The use of object-oriented concepts for analysis and design only, with a method and
notation that cannot be used to write executable software. 
• The use of an object-oriented programming language which is not suitable for
analysis and design. 

An object-oriented language and environment, together with the supporting
method, should apply to the entire lifecycle, in a way that minimizes the gaps
between successive activities.

Classes as modules:
Object orientation is primarily an architectural technique: its major effect is on the
modular structure of software systems. 
The key role here is again played by classes. A class describes not just a type of
objects but also a modular unit. In a pure object-oriented approach: Classes should be the only modules.

Classes as types:
Every type should be based on a class.

Single inheritance:
Software development involves a large number of classes; many are variants of others. To
control the resulting potential complexity, we need a classification mechanism, known as
inheritance.


----------------------------------The road to object orientation-------------------------

Modularity:

This chapter introduces a set of complementary properties: five criteria, five rules and five principles of modularity.

FIVE CRITERIA

A design method worthy of being called “modular” should satisfy five fundamental
requirements, explored in the next few sections: 
• Decomposability. 
• Composability. 
• Understandability. 
• Continuity. 
• Protection.

Modular decomposability:

Imagine you have a big problem to solve, like building a complicated piece of software. It's too overwhelming to tackle all at once, so you break it down into smaller, more manageable parts or "subproblems."
However, even these smaller parts can still be pretty tricky on their own. So, you might need to break them down further into even smaller pieces. This process can repeat until each piece is simple enough to handle.
Now, once you have these smaller pieces, you can assign different people or groups to work on them. This is like dividing up the work so that everyone can focus on their own part.
But here's the tricky part: these smaller pieces shouldn't rely too much on each other. If they do, it could slow down the progress because one piece can't move forward until another is done.
Also, it's really important to understand how these pieces are related to each other. If we miss any connections between them, we might end up with individual parts that work okay by themselves but don't fit together properly to solve the original big problem.

So, in simple terms, the passage is basically saying that when we're solving big problems by breaking them into smaller parts, we need to make sure those parts are simple enough to handle and don't rely too much on each other. Plus, we need to understand how they all fit together in the end.


Top-down design follows the principle of decomposability by breaking down the system into smaller,manageable parts, the inclusion of a global initialization module 
undermines this principle by creating interdependencies between modules \and compromising their autonomy

Modular composability:

The concept of composability in software design, which is the opposite of decomposability.
While decomposability focuses on breaking down complex systems into smaller subsystems, 
composability deals with extracting existing software elements from their original context to be reused in different contexts.

Composability vs. Decomposability: 
Composability addresses the reverse process of decomposability. Instead of breaking down a complex system into smaller parts, composability involves extracting
existing software elements from their original design context to be reused elsewhere.

Composability in software design aims to make software elements independent enough to be extracted and reused in different contexts, thus promoting reusability and efficiency in development

The relationship between composability and decomposability in modular design methods:

1. **Independence of Composability and Decomposability**:
   - Composability and decomposability are two separate criteria for evaluating modular design methods.
   - They are often at odds with each other, meaning that a method that excels in one criterion may not necessarily perform well in the other.
   - For example, top-down design, which is favored for decomposability, may not inherently support composability.

2. **Top-Down Design and Decomposability**:
   - Top-down design involves breaking down a complex system into smaller, more manageable modules or subsystems.
   - While this approach is effective for decomposing a problem into smaller parts, the resulting modules may not be easily combinable with modules from other sources.
   - This is because top-down design typically focuses on developing each module to fulfill a specific requirement or subproblem identified during the refinement process.
   - As a result, these modules may be closely tied to the immediate context in which they were developed and may not be adaptable to other contexts.

3. **Limitations of Top-Down Design**:
   - Top-down design lacks mechanisms for making modules more general than immediately required or for identifying commonalities and redundancies between modules obtained from different parts of the hierarchy.
   - It does not provide hints or incentives for designing modules with broader applicability beyond their original context.

4. **Complementarity of Composability and Decomposability**:
   - The fact that both composability and decomposability are necessary criteria for a modular method reflects the need for a balance between top-down and bottom-up reasoning.
   - This balance acknowledges the importance of both breaking down complex problems into manageable parts (decomposability) and ensuring that these parts can be easily combined and reused in different contexts (composability).

In summary, the passage highlights the challenges of achieving both composability and decomposability in modular design methods and emphasizes the complementary nature of these criteria, which reflect the balance between top-down and bottom-up reasoning in software design.

